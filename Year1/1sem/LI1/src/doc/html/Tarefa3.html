<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Tarefa3</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption empty">&nbsp;</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>Safe</td></tr></table><p class="caption">Tarefa3</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Fun&#231;&#245;es usadas para converter pe&#231;as em instru&#231;&#245;es</a></li><li><a href="#g:2">Fun&#231;&#245;es utilizadas para compactar as instru&#231;&#245;es de um corredor e criar uma lista de <em>Instrution</em> correspondente a todos os corredores do labirinto</a></li><li><a href="#g:3">Fun&#231;&#227;o utilizada para retirar <em>Intructions</em> repetidas e troc&#225;-las por <code>&quot;Repeat n&quot;</code> (sendo n a posi&#231;&#227;o na lista onde uma determinada <em>Instruction</em> aparece pela primeira vez)</a></li><li><a href="#g:4"><strong>Objetivo final da Tarefa 3</strong></a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p><strong>Nesta tarefa, o objetivo foi criar um conjunto de fun&#231;&#245;es com a finalidade de converter o labirinto para um conjunto de instru&#231;&#245;es (menor poss&#237;vel).</strong> </p></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"><li class="src short"><a href="#v:fromPieceToInst">fromPieceToInst</a> :: <a href="Types.html#t:Piece" title="Types">Piece</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a></li><li class="src short"><a href="#v:fromCorridorToInst">fromCorridorToInst</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [<a href="Types.html#t:Instruction" title="Types">Instruction</a>]</li><li class="src short"><a href="#v:compactCorridor">compactCorridor</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a></li><li class="src short"><a href="#v:compactMazeBeta">compactMazeBeta</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Instruction" title="Types">Instruction</a>]</li><li class="src short"><a href="#v:repeats">repeats</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; Int -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li><li class="src short"><a href="#v:compactMaze">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a></li></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Fun&#231;&#245;es usadas para converter pe&#231;as em instru&#231;&#245;es</h1></a><div class="top"><p class="src"><a id="v:fromPieceToInst" class="def">fromPieceToInst</a> :: <a href="Types.html#t:Piece" title="Types">Piece</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a> <a href="#v:fromPieceToInst" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o</h2><p>Esta fun&#231;&#227;o &#233; utilizada para converter uma pe&#231;a numa instru&#231;&#227;o e constitui o primeiro passo para converter todo o labirinto em <em>Instructions</em>.</p><h2>Exemplos</h2><ul><li><pre>fromPieceToInst Wall = Instruct [(1,Wall)]</pre></li><li><pre>fromPieceToInst Empty = Instruct [(1,Empty)]</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:fromCorridorToInst" class="def">fromCorridorToInst</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; [<a href="Types.html#t:Instruction" title="Types">Instruction</a>] <a href="#v:fromCorridorToInst" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o</h2><p>Nesta fun&#231;&#227;o, &#233; usada a fun&#231;&#227;o anterior em todos os elementos do corredor e devolve uma lista de <em>Instruction</em> que ser&#225; a base das fun&#231;&#245;es posteriores para comprimir a informa&#231;&#227;o.</p><h2>Exemplos</h2><ul><li><pre>fromCorridorToInst [Wall,Wall] = [Instruct [(1,Wall)],Instruct [(1,Wall)]]</pre></li><li><pre>fromCorridorToInst [Food Big,Empty,Food Little] = [Instruct [(1,Food Big)],Instruct [(1,Empty)],Instruct [(1,Food Little)]]</pre></li></ul></div></div><a href="#g:2" id="g:2"><h1>Fun&#231;&#245;es utilizadas para compactar as instru&#231;&#245;es de um corredor e criar uma lista de <em>Instrution</em> correspondente a todos os corredores do labirinto</h1></a><div class="top"><p class="src"><a id="v:compactCorridor" class="def">compactCorridor</a> :: <a href="Types.html#t:Corridor" title="Types">Corridor</a> -&gt; <a href="Types.html#t:Instruction" title="Types">Instruction</a> <a href="#v:compactCorridor" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o </h2><p>Esta fun&#231;&#227;o usa as fun&#231;&#245;es <strong>fromCorridorToInst</strong>; <strong>agrupaIguais</strong> (tal como o nome sugere, agrupa instru&#231;&#245;es iguais); <strong>compactaInstAux</strong> (recebe uma lista de listas e une as listas (com instru&#231;&#245;es iguais) do tipo &quot;<code>Instruct [(1,Piece)]</code>&quot;, criando, desta forma, instru&#231;o&#7869;s do tipo &quot;<code>Instruct [(n,Piece)]</code>&quot;, 
 sendo n-1 o n&#250;mero de vezes que a pe&#231;a se repete seguidamente num determinado segmento) e <strong>aux2</strong> que usa o output anterior como argumento para criar listas de tuplos do tipo <code>[(Int,Piece)]</code>, complilando todos os tuplos que recebe numa s&#243; lista. Finalmente, &#233; adicionado o &quot;<code>Instruct</code>&quot; no in&#237;cio para corresponder ao tipo do output da fun&#231;&#227;o <strong>compactCorridor</strong>.   </p><h2>Exemplos</h2><ul><li><pre>compactCorridor [Wall,Wall,Wall] = Instruct [(3,Wall)]</pre></li><li><pre>compactCorridor [Wall,Empty,Empty,Food Little] = Instruct [(1,Wall),(2,Empty),(1,Food Little)]</pre></li></ul></div></div><div class="top"><p class="src"><a id="v:compactMazeBeta" class="def">compactMazeBeta</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; [<a href="Types.html#t:Instruction" title="Types">Instruction</a>] <a href="#v:compactMazeBeta" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o </h2><p>Esta fun&#231;&#227;o aplica a fun&#231;&#227;o <strong>compactCorridor</strong> a todos os corredores do <em>Maze</em> fornecido e devolve, portanto, uma lista de <em>Intruction</em> em que cada elmento corresponde a um corredor (pela ordem como est&#227;o dispostos no labirinto).</p><h2>Exemplos</h2><ul><li><pre>compactMazeBeta [[Wall,Wall,Wall],[Empty,Food Little,Empty],[Wall,Wall,Wall]] = [Instruct [(3,Wall)],Instruct [(1,Empty),(1,Food Little),(1,Empty)],Instruct [(3,Wall)]]</pre></li><li><pre>compactMazeBeta [[Wall,Wall,Wall,Wall],[Wall,Food Big,Food Little,Wall],[Wall,Wall,Wall,Wall]] = [Instruct [(4,Wall)],Instruct [(1,Wall),(1,Food Big),(1,Food Little),(1,Wall)],Instruct [(4,Wall)]]</pre></li></ul></div></div><a href="#g:3" id="g:3"><h1>Fun&#231;&#227;o utilizada para retirar <em>Intructions</em> repetidas e troc&#225;-las por <code>&quot;Repeat n&quot;</code> (sendo n a posi&#231;&#227;o na lista onde uma determinada <em>Instruction</em> aparece pela primeira vez)</h1></a><div class="top"><p class="src"><a id="v:repeats" class="def">repeats</a> :: <a href="Types.html#t:Instructions" title="Types">Instructions</a> -&gt; Int -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:repeats" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o</h2><p>A fun&#231;ao <strong>repeats</strong> recebe uma lista do tipo <em>Instructions</em> e um acumulador (que ser&#225; <strong>0</strong> no contexto deste problema) e testa, primeiramente, se o primeiro elemento da <em>Instructions</em> (ou seja, da lista de <em>Instruction</em>) pertence &#224; <em>tail</em> da lista e se n&#227;o &#233; do tipo &quot;<code>Repeat n</code>&quot;. 
 <strong>Nota:</strong> o primeiro elemento nunca ser&#225; do tipo &quot;<code>Repeat n</code>&quot; se o primeiro argumento da fun&#231;&#227;o for a aplica&#231;&#227;o da fun&#231;&#227;o <strong>compactMazeBeta</strong> a 
 um determinado labirinto. </p><h3>Se ambas as condi&#231;&#245;es forem satisfeitas: </h3><p>A fun&#231;&#227;o &#233; aplicada &#224; express&#227;o: &quot;<strong><code>([x] ++ (trocaNasLinhasN (Repeat ac) (mapearIguais x xs) xs))</code></strong>&quot; (sendo <strong><code>(x:xs)</code></strong> a lista de <em>Instruction</em> e <strong><code>ac</code></strong> o acumulador do tipo <em>Int</em>)  
 utilizando o mesmo acumulador como segundo argumento. </p><p>A fun&#231;&#227;o <strong>trocaNasLinhasN</strong> recebe um determinado elemento e duas listas (sendo a primeira, uma lista de inteiros), e devolve uma lista. Admitindo que os argumentos desta fun&#231;&#227;o s&#227;o <strong><code>a</code></strong>, <strong><code>l1</code></strong> e <strong><code>l2</code></strong>, a fun&#231;&#227;o
 <strong>trocaNasLinhasN</strong>, troca o elemento <strong><code>a</code></strong> por todos os elementos da lista <strong><code>l2</code></strong> cujo valor da posi&#231;&#227;o na lista esteja contido na lista <strong><code>l1</code></strong>.</p><p>A fun&#231;&#227;o <strong>mapearIguais</strong> recebe um elemento e uma lista de elementos, e devolve uma lista de inteiros. Sendo <strong><code>a</code></strong> e <strong><code>l</code></strong> os argumentos da fun&#231;&#227;o (por esta ordem), a fun&#231;&#227;o <strong>mapearIguais</strong> devolve uma lista com as posi&#231;&#245;es dos elementos da lista <strong><code>l</code></strong> que s&#227;o iguais a iguais a <strong><code>a</code></strong>.</p><h3>Se umas das condi&#231;&#245;es for falsa:</h3><p>A func&#227;o ir&#225; calcular o resultado da express&#227;o: &quot;<strong><code>x : repeats xs (ac+1)</code></strong>&quot;. <strong>Nota:</strong> o resultado final &#233; apresentado pela fun&#231;&#227;o quando nesta n&#227;o contiver quaisquer express&#245;es do tipo <code>&quot;Instruct i&quot;</code> iguais, sendo <strong>i</strong> uma lista de <strong><code>(Int,Piece)</code></strong>.</p><h2>Exemplos</h2><ul><li><pre>repeats <strong>[Instruct [(3,Wall)]</strong>,Instruct [(1,Empty),(1,Food Little),(1,Empty)],<strong>Instruct [(3,Wall)]</strong>] 0 = [Instruct [(3,#)],Instruct [(1,Empty),(1,Food Little),(1,Empty)],<strong>Repeat 0</strong>]</pre></li><li><pre>repeats <strong>[Instruct [(4,Wall)]</strong>,<strong>Instruct [(1,Wall),(2,Empty),(1,Wall)]</strong>,<strong>Instruct [(1,Wall),(2,Empty),(1,Wall)]</strong>,<strong>Instruct [(4,Wall)]]</strong> 0 = [Instruct [(4,Wall)],Instruct [(1,Wall),(2,Empty),(1,Wall)],<strong>Repeat 1</strong>,<strong>Repeat 0</strong>]</pre></li></ul><p><strong>Nota:</strong> Nos exemplos acima apresentados, foram deixadas a negrito as <em>Instruction</em> iguais que a fun&#231;&#227;o recebeu e os &quot;<code>Repeat n</code>&quot; no seu resultado.</p></div></div><a href="#g:4" id="g:4"><h1><strong>Objetivo final da Tarefa 3</strong></h1></a><div class="top"><p class="src"><a id="v:compactMaze" class="def">compactMaze</a> :: <a href="Types.html#t:Maze" title="Types">Maze</a> -&gt; <a href="Types.html#t:Instructions" title="Types">Instructions</a> <a href="#v:compactMaze" class="selflink">#</a></p><div class="doc"><h2>Descri&#231;&#227;o da fun&#231;&#227;o</h2><p>Esta fun&#231;&#227;o aplica a fun&#231;&#227;o <strong>compactMazeBeta</strong> ao <em>Maze</em> que recebe como input 
 e usa o resultado como primeiro argumento da fun&#231;&#227;o <strong>repeats</strong>, sendo o segundo argumento <strong>0</strong>. Simplificando, a fun&#231;&#227;o faz a seguinte opera&#231;&#227;o: &quot;<strong><code>repeats (compactMazeBeta m) 0</code></strong>&quot; (sendo <strong>m</strong> o <em>Maze</em> que a fun&#231;&#227;o <strong>compactMaze</strong> recebe).</p><h2>Exemplos </h2><ul><li><pre>compactMaze [<strong>[Wall,Wall,Wall]</strong>,[Wall,Empty,Wall],<strong>[Wall,Wall,Wall]</strong>] = [Instruct [(3,Wall)],Instruct [(1,Wall),(1,Empty),(1,Wall)],<strong>Repeat 0</strong>]</pre></li><li><pre>compactMaze [<strong>[Wall,Wall,Wall,Wall]</strong>,<strong>[Wall,Empty,Food Little,Wall]</strong>,[Wall,Food Big,Empty,Wall],<strong>[Wall,Empty,Food Little,Wall]</strong>,[Wall,Empty,Empty,Wall],<strong>[Wall,Wall,Wall,Wall]</strong>] = [Instruct [(4,Wall)],Instruct [(1,Wall),(1,Empty),(1,Food Little),(1,Wall)],Instruct [(1,Wall),(1,Food Big),(1,Empty),(1,Wall)],<strong>Repeat 1</strong>,Instruct [(1,Wall),(2,Empty),(1,Wall)],<strong>Repeat 0</strong>]</pre></li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.22.0</p></div></body></html>